-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at https://mozilla.org/MPL/2.0/.



-- app = link {
--   name = "app",
--   objs = {
--     main(),
--     libfoo(),
--   },
-- }

-- local main = cc_object {
--   target = "main.c",
--   hdrscan = true,
-- }

-- local libfoo = download {
--   out = "libfoo.o",
--   url = "........",
--   md5 = "........",
-- }

------------- CORE

-- Generated by ChatGPT3.5
local function flattentable(tbl, valuesList)
    for _, value in pairs(tbl) do
        if type(value) == "table" then
            flattentable(value, valuesList) -- Recursively remove keys for nested tables
        else
            table.insert(valuesList, value) -- Keep the value
        end
    end
end

function sumids(ents)
  buf = ""
  for i, e in ipairs(ents) do
    print("--- [IDENTIFY]", e.name, e:identify()) -- TODO remove this
    buf = buf .. e:identify()
  end
  return buf
end

function task(ops)
  return function()
    srcs = ops.fetch()
    flatsrcs = {}
    flattentable(srcs, flatsrcs)

    flatouts = {}
    flattentable(ops.yield, flatouts)
    initial_build = false
    for i, output in ipairs(flatouts) do
      print("--- [CHECK EXISTS]", output.name)
      if not output:exists() then
        initial_build = true
        break
      end
    end

    -- TODO: in future depend only on build(), not whole smeltfile
    insid = sumids(flatsrcs) .. file("SMELT.lua"):identify()
    print("--- [IDENTIFY]", file("SMELT.lua").name)  -- dbg
    if not initial_build then
      currentid = insid .. sumids(flatouts)
    end
    -- print(sumids(flatouts))

    if initial_build or not cache_search(currentid) then
      print("[BUILDING]")
      ops.build(srcs)
      print("[CACHING]")
      cache_add(insid .. sumids(flatouts))
      return ops.yield
    end

    return ops.yield
  end
end

------------- UTILS

-- https://stackoverflow.com/questions/11669926/is-there-a-lua-equivalent-of-scalas-map-or-cs-select-function
function map(f, t)
    local t1 = {}
    local t_len = #t
    for i = 1, t_len do
        t1[i] = f(t[i])
    end
    return t1
end

function tofile(f)
  if type(f) == "userdata" then 
    return f
  end
  return file(f)
end


------------- CONSTRUCTS

-- Make-style simple construct for deriving files using commands
-- srcs = table of input names/files
-- outs = table of output names/files
-- cmds = list of system commands to run
function make(opts)
  fsrcs = {}
  flattentable(opts.srcs, fsrcs)
  opts.srcs = map(tofile, fsrcs)
  return task {
    fetch = function() 
      return opts.srcs
    end,
    build = function(srcs)
      for _, c in ipairs(opts.cmds) do
        os.execute(c)
      end
    end,
    yield = map(tofile, opts.outs),
  }
end

-- Compile a single C file using gcc
-- name = C name/file 
-- outf = name/file to write to
function gcc_executable(opts)
  opts.name = tofile(opts.name)
  opts.outf = tofile(opts.outf)
  return task {
    fetch = function ()
     return { main = opts.name }
    end,
    build = function (srcs)
      os.execute("gcc " .. srcs.main.name .. " -o " .. opts.outf.name )
    end,
    yield = { output = opts.outf } 
  } 
end

